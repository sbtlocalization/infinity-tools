// Code generated by kaitai-struct-compiler from a .ksy source file. DO NOT EDIT.

package parser

import (
	"github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"
	"bytes"
	"io"
)


/**
 * This file format acts as a central reference point to locate files required
 * by the game (in a BIFF file on a CD or in the override directory). The key
 * file also maintains a mapping from an 8 byte resource name (refref) to a
 * 32 byte ID (using the lowest 12 bits to identify a resource). There is
 * generally only one key file with each game (chitin.key).
 * @see <a href="https://gibberlings3.github.io/iesdp/file_formats/ie_formats/key_v1.htm
 * ">Source</a>
 */
type Key struct {
	Magic []byte
	Version []byte
	NumBiffEntries uint32
	NumResEntries uint32
	OfsBiffEntries uint32
	OfsResEntries uint32
	_io *kaitai.Stream
	_root *Key
	_parent kaitai.Struct
	_f_biffEntries bool
	biffEntries []*Key_BiffEntry
	_f_resEntries bool
	resEntries []*Key_ResEntry
}
func NewKey() *Key {
	return &Key{
	}
}

func (this Key) IO_() *kaitai.Stream {
	return this._io
}

func (this *Key) Read(io *kaitai.Stream, parent kaitai.Struct, root *Key) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp1, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp1 = tmp1
	this.Magic = tmp1
	if !(bytes.Equal(this.Magic, []uint8{75, 69, 89, 32})) {
		return kaitai.NewValidationNotEqualError([]uint8{75, 69, 89, 32}, this.Magic, this._io, "/seq/0")
	}
	tmp2, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp2 = tmp2
	this.Version = tmp2
	if !(bytes.Equal(this.Version, []uint8{86, 49, 32, 32})) {
		return kaitai.NewValidationNotEqualError([]uint8{86, 49, 32, 32}, this.Version, this._io, "/seq/1")
	}
	tmp3, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.NumBiffEntries = uint32(tmp3)
	tmp4, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.NumResEntries = uint32(tmp4)
	tmp5, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.OfsBiffEntries = uint32(tmp5)
	tmp6, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.OfsResEntries = uint32(tmp6)
	return err
}
func (this *Key) BiffEntries() (v []*Key_BiffEntry, err error) {
	if (this._f_biffEntries) {
		return this.biffEntries, nil
	}
	this._f_biffEntries = true
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64(this._root.OfsBiffEntries), io.SeekStart)
	if err != nil {
		return nil, err
	}
	for i := 0; i < int(this.NumBiffEntries); i++ {
		_ = i
		tmp7 := NewKey_BiffEntry()
		err = tmp7.Read(this._io, this, this._root)
		if err != nil {
			return nil, err
		}
		this.biffEntries = append(this.biffEntries, tmp7)
	}
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	return this.biffEntries, nil
}
func (this *Key) ResEntries() (v []*Key_ResEntry, err error) {
	if (this._f_resEntries) {
		return this.resEntries, nil
	}
	this._f_resEntries = true
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64(this._root.OfsResEntries), io.SeekStart)
	if err != nil {
		return nil, err
	}
	for i := 0; i < int(this.NumResEntries); i++ {
		_ = i
		tmp8 := NewKey_ResEntry()
		err = tmp8.Read(this._io, this, this._root)
		if err != nil {
			return nil, err
		}
		this.resEntries = append(this.resEntries, tmp8)
	}
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	return this.resEntries, nil
}
type Key_BiffEntry struct {
	LenFile uint32
	OfsFileName uint32
	LenFileName uint16
	LocationBits *Key_BiffEntry_Location
	_io *kaitai.Stream
	_root *Key
	_parent kaitai.Struct
	_raw_LocationBits []byte
	_f_fileNameExt bool
	fileNameExt string
}
func NewKey_BiffEntry() *Key_BiffEntry {
	return &Key_BiffEntry{
	}
}

func (this Key_BiffEntry) IO_() *kaitai.Stream {
	return this._io
}

func (this *Key_BiffEntry) Read(io *kaitai.Stream, parent kaitai.Struct, root *Key) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp9, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.LenFile = uint32(tmp9)
	tmp10, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.OfsFileName = uint32(tmp10)
	tmp11, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.LenFileName = uint16(tmp11)
	tmp12, err := this._io.ReadBytes(int(2))
	if err != nil {
		return err
	}
	tmp12 = tmp12
	this._raw_LocationBits = tmp12
	_io__raw_LocationBits := kaitai.NewStream(bytes.NewReader(this._raw_LocationBits))
	tmp13 := NewKey_BiffEntry_Location()
	err = tmp13.Read(_io__raw_LocationBits, this, this._root)
	if err != nil {
		return err
	}
	this.LocationBits = tmp13
	return err
}
func (this *Key_BiffEntry) FileNameExt() (v string, err error) {
	if (this._f_fileNameExt) {
		return this.fileNameExt, nil
	}
	this._f_fileNameExt = true
	thisIo := this._root._io
	_pos, err := thisIo.Pos()
	if err != nil {
		return "", err
	}
	_, err = thisIo.Seek(int64(this.OfsFileName), io.SeekStart)
	if err != nil {
		return "", err
	}
	tmp14, err := thisIo.ReadBytes(int(this.LenFileName))
	if err != nil {
		return "", err
	}
	tmp14 = kaitai.BytesTerminate(tmp14, 0, false)
	this.fileNameExt = string(tmp14)
	_, err = thisIo.Seek(_pos, io.SeekStart)
	if err != nil {
		return "", err
	}
	return this.fileNameExt, nil
}
type Key_BiffEntry_Location struct {
	InData bool
	InCache bool
	Cd1 bool
	Cd2 bool
	Cd3 bool
	Cd4 bool
	Cd5 bool
	Cd6 bool
	_io *kaitai.Stream
	_root *Key
	_parent *Key_BiffEntry
}
func NewKey_BiffEntry_Location() *Key_BiffEntry_Location {
	return &Key_BiffEntry_Location{
	}
}

func (this Key_BiffEntry_Location) IO_() *kaitai.Stream {
	return this._io
}

func (this *Key_BiffEntry_Location) Read(io *kaitai.Stream, parent *Key_BiffEntry, root *Key) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp15, err := this._io.ReadBitsIntLe(1)
	if err != nil {
		return err
	}
	this.InData = tmp15 != 0
	tmp16, err := this._io.ReadBitsIntLe(1)
	if err != nil {
		return err
	}
	this.InCache = tmp16 != 0
	tmp17, err := this._io.ReadBitsIntLe(1)
	if err != nil {
		return err
	}
	this.Cd1 = tmp17 != 0
	tmp18, err := this._io.ReadBitsIntLe(1)
	if err != nil {
		return err
	}
	this.Cd2 = tmp18 != 0
	tmp19, err := this._io.ReadBitsIntLe(1)
	if err != nil {
		return err
	}
	this.Cd3 = tmp19 != 0
	tmp20, err := this._io.ReadBitsIntLe(1)
	if err != nil {
		return err
	}
	this.Cd4 = tmp20 != 0
	tmp21, err := this._io.ReadBitsIntLe(1)
	if err != nil {
		return err
	}
	this.Cd5 = tmp21 != 0
	tmp22, err := this._io.ReadBitsIntLe(1)
	if err != nil {
		return err
	}
	this.Cd6 = tmp22 != 0
	return err
}
type Key_ResEntry struct {
	Name string
	Type uint16
	Locator *Key_ResEntry_Locator
	_io *kaitai.Stream
	_root *Key
	_parent *Key
}
func NewKey_ResEntry() *Key_ResEntry {
	return &Key_ResEntry{
	}
}

func (this Key_ResEntry) IO_() *kaitai.Stream {
	return this._io
}

func (this *Key_ResEntry) Read(io *kaitai.Stream, parent *Key, root *Key) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp23, err := this._io.ReadBytes(int(8))
	if err != nil {
		return err
	}
	tmp23 = kaitai.BytesTerminate(tmp23, 0, false)
	this.Name = string(tmp23)
	tmp24, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.Type = uint16(tmp24)
	tmp25 := NewKey_ResEntry_Locator()
	err = tmp25.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Locator = tmp25
	return err
}
type Key_ResEntry_Locator struct {
	FileIndex uint64
	TilesetIndex uint64
	BiffFileIndex uint64
	_io *kaitai.Stream
	_root *Key
	_parent *Key_ResEntry
	_f_biffFile bool
	biffFile *Key_BiffEntry
}
func NewKey_ResEntry_Locator() *Key_ResEntry_Locator {
	return &Key_ResEntry_Locator{
	}
}

func (this Key_ResEntry_Locator) IO_() *kaitai.Stream {
	return this._io
}

func (this *Key_ResEntry_Locator) Read(io *kaitai.Stream, parent *Key_ResEntry, root *Key) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp26, err := this._io.ReadBitsIntLe(14)
	if err != nil {
		return err
	}
	this.FileIndex = tmp26
	tmp27, err := this._io.ReadBitsIntLe(6)
	if err != nil {
		return err
	}
	this.TilesetIndex = tmp27
	tmp28, err := this._io.ReadBitsIntLe(12)
	if err != nil {
		return err
	}
	this.BiffFileIndex = tmp28
	return err
}
func (this *Key_ResEntry_Locator) BiffFile() (v *Key_BiffEntry, err error) {
	if (this._f_biffFile) {
		return this.biffFile, nil
	}
	this._f_biffFile = true
	thisIo := this._root._io
	_pos, err := thisIo.Pos()
	if err != nil {
		return nil, err
	}
	_, err = thisIo.Seek(int64(this._root.OfsBiffEntries + this.BiffFileIndex * 12), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp29 := NewKey_BiffEntry()
	err = tmp29.Read(thisIo, this, this._root)
	if err != nil {
		return nil, err
	}
	this.biffFile = tmp29
	_, err = thisIo.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	return this.biffFile, nil
}
