// Code generated by kaitai-struct-compiler from a .ksy source file. DO NOT EDIT.

package parser

import (
	"github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"
	"bytes"
	"io"
)


/**
 * This file format acts as a central reference point to locate files required
 * by the game (in a BIFF file on a CD or in the override directory). The key
 * file also maintains a mapping from an 8 byte resource name (refref) to a
 * 32 byte ID (using the lowest 12 bits to identify a resource). There is
 * generally only one key file with each game (chitin.key).
 * @see <a href="https://gibberlings3.github.io/iesdp/file_formats/ie_formats/key_v1.htm
 * ">Source</a>
 */
type Key struct {
	Magic []byte
	Version []byte
	NumBiffEntries uint32
	NumResEntries uint32
	OfsBiffEntries uint32
	OfsResEntries uint32
	_io *kaitai.Stream
	_root *Key
	_parent kaitai.Struct
	_f_biffEntries bool
	biffEntries []*Key_BiffEntry
	_f_resEntries bool
	resEntries []*Key_ResEntry
}
func NewKey() *Key {
	return &Key{
	}
}

func (this Key) IO_() *kaitai.Stream {
	return this._io
}

func (this *Key) Read(io *kaitai.Stream, parent kaitai.Struct, root *Key) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp1, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp1 = tmp1
	this.Magic = tmp1
	if !(bytes.Equal(this.Magic, []uint8{75, 69, 89, 32})) {
		return kaitai.NewValidationNotEqualError([]uint8{75, 69, 89, 32}, this.Magic, this._io, "/seq/0")
	}
	tmp2, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp2 = tmp2
	this.Version = tmp2
	if !(bytes.Equal(this.Version, []uint8{86, 49, 32, 32})) {
		return kaitai.NewValidationNotEqualError([]uint8{86, 49, 32, 32}, this.Version, this._io, "/seq/1")
	}
	tmp3, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.NumBiffEntries = uint32(tmp3)
	tmp4, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.NumResEntries = uint32(tmp4)
	tmp5, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.OfsBiffEntries = uint32(tmp5)
	tmp6, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.OfsResEntries = uint32(tmp6)
	return err
}
func (this *Key) BiffEntries() (v []*Key_BiffEntry, err error) {
	if (this._f_biffEntries) {
		return this.biffEntries, nil
	}
	this._f_biffEntries = true
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64(this._root.OfsBiffEntries), io.SeekStart)
	if err != nil {
		return nil, err
	}
	for i := 0; i < int(this.NumBiffEntries); i++ {
		_ = i
		tmp7 := NewKey_BiffEntry()
		err = tmp7.Read(this._io, this, this._root)
		if err != nil {
			return nil, err
		}
		this.biffEntries = append(this.biffEntries, tmp7)
	}
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	return this.biffEntries, nil
}
func (this *Key) ResEntries() (v []*Key_ResEntry, err error) {
	if (this._f_resEntries) {
		return this.resEntries, nil
	}
	this._f_resEntries = true
	_pos, err := this._io.Pos()
	if err != nil {
		return nil, err
	}
	_, err = this._io.Seek(int64(this._root.OfsResEntries), io.SeekStart)
	if err != nil {
		return nil, err
	}
	for i := 0; i < int(this.NumResEntries); i++ {
		_ = i
		tmp8 := NewKey_ResEntry()
		err = tmp8.Read(this._io, this, this._root)
		if err != nil {
			return nil, err
		}
		this.resEntries = append(this.resEntries, tmp8)
	}
	_, err = this._io.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	return this.resEntries, nil
}
type Key_BiffEntry struct {
	LenFile uint32
	Offset uint32
	LenFileNameExt uint16
	LocationBits uint16
	_io *kaitai.Stream
	_root *Key
	_parent *Key
	_raw_fileNameExt []byte
	_f_fileNameExt bool
	fileNameExt *Key_FileName
}
func NewKey_BiffEntry() *Key_BiffEntry {
	return &Key_BiffEntry{
	}
}

func (this Key_BiffEntry) IO_() *kaitai.Stream {
	return this._io
}

func (this *Key_BiffEntry) Read(io *kaitai.Stream, parent *Key, root *Key) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp9, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.LenFile = uint32(tmp9)
	tmp10, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Offset = uint32(tmp10)
	tmp11, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.LenFileNameExt = uint16(tmp11)
	tmp12, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.LocationBits = uint16(tmp12)
	return err
}
func (this *Key_BiffEntry) FileNameExt() (v *Key_FileName, err error) {
	if (this._f_fileNameExt) {
		return this.fileNameExt, nil
	}
	this._f_fileNameExt = true
	thisIo := this._root._io
	_pos, err := thisIo.Pos()
	if err != nil {
		return nil, err
	}
	_, err = thisIo.Seek(int64(this.Offset), io.SeekStart)
	if err != nil {
		return nil, err
	}
	tmp13, err := thisIo.ReadBytes(int(this.LenFileNameExt))
	if err != nil {
		return nil, err
	}
	tmp13 = tmp13
	this._raw_fileNameExt = tmp13
	_io__raw_fileNameExt := kaitai.NewStream(bytes.NewReader(this._raw_fileNameExt))
	tmp14 := NewKey_FileName()
	err = tmp14.Read(_io__raw_fileNameExt, this, this._root)
	if err != nil {
		return nil, err
	}
	this.fileNameExt = tmp14
	_, err = thisIo.Seek(_pos, io.SeekStart)
	if err != nil {
		return nil, err
	}
	return this.fileNameExt, nil
}
type Key_FileName struct {
	Name string
	_io *kaitai.Stream
	_root *Key
	_parent *Key_BiffEntry
}
func NewKey_FileName() *Key_FileName {
	return &Key_FileName{
	}
}

func (this Key_FileName) IO_() *kaitai.Stream {
	return this._io
}

func (this *Key_FileName) Read(io *kaitai.Stream, parent *Key_BiffEntry, root *Key) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp15, err := this._io.ReadBytesTerm(0, false, true, true)
	if err != nil {
		return err
	}
	this.Name = string(tmp15)
	return err
}
type Key_ResEntry struct {
	Name string
	Type uint16
	Locator uint32
	_io *kaitai.Stream
	_root *Key
	_parent *Key
	_f_nonTilesetIndex bool
	nonTilesetIndex int
	_f_sourceIndex bool
	sourceIndex int
	_f_tilesetIndex bool
	tilesetIndex int
}
func NewKey_ResEntry() *Key_ResEntry {
	return &Key_ResEntry{
	}
}

func (this Key_ResEntry) IO_() *kaitai.Stream {
	return this._io
}

func (this *Key_ResEntry) Read(io *kaitai.Stream, parent *Key, root *Key) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp16, err := this._io.ReadBytes(int(8))
	if err != nil {
		return err
	}
	tmp16 = kaitai.BytesTerminate(tmp16, 0, false)
	this.Name = string(tmp16)
	tmp17, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.Type = uint16(tmp17)
	tmp18, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Locator = uint32(tmp18)
	return err
}
func (this *Key_ResEntry) NonTilesetIndex() (v int, err error) {
	if (this._f_nonTilesetIndex) {
		return this.nonTilesetIndex, nil
	}
	this._f_nonTilesetIndex = true
	this.nonTilesetIndex = int(this.Locator & 16383)
	return this.nonTilesetIndex, nil
}
func (this *Key_ResEntry) SourceIndex() (v int, err error) {
	if (this._f_sourceIndex) {
		return this.sourceIndex, nil
	}
	this._f_sourceIndex = true
	this.sourceIndex = int((this.Locator & uint32(4293918720)) >> 20)
	return this.sourceIndex, nil
}
func (this *Key_ResEntry) TilesetIndex() (v int, err error) {
	if (this._f_tilesetIndex) {
		return this.tilesetIndex, nil
	}
	this._f_tilesetIndex = true
	this.tilesetIndex = int((this.Locator & 1032192) >> 14)
	return this.tilesetIndex, nil
}
